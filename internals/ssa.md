# SSA IR

The SSA IR is the primary IR used by the compiler for target agnostic optimizations, and takes the form of quadruples. 

## SSA Format

The SSA is made up of a vector of functions, which are made up of a vector of basic blocks, which are then made up of a vector of operations.

Besides calling functions each operation takes a set number of variables, and optionally returns a value into the register on the left hand, which can be a symbolic register or nothing. 

### Datatypes

* Symbolic registers, which are given a name (in the case of function parameters) or a number (in the case of autogenerated symbolic registers), prefixed by %
* Integer literals, prefixed by $

#### Types

The SSA is very weakly typed with types implemented as functions on bit vectors.

There are 4 data types all bit vectors, 8, 16, 32, and 64. They are both bit vectors with no signedness to them.

### Operations

* add - adds two bit vectors of the same size (doesn't care about sign)
* sub - same as add but subtraction
* imul - same as add but multiplication (acts as if they are signed)
* umul - same as add but multiplication (acts as if they are unsigned)
* idiv - divides two bit vectors of the same size (acts as if they are signed)
* udiv - divides two bit vectors of the same size (acts as if they are unsigned)
* ret  - returns from the current function

### Examples

%1 =32 $48
%2 =32 $52
%3 =32 add %1 %2
ret %3
